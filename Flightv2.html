<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Addict 0 - Retro Flight Combat</title>
    <script async src="https://unpkg.com/es-module-shims/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
        }
    }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(135deg, #1a237e 0%, #7c4dff 100%);
        }

        #gameOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(26, 35, 126, 0.9) 0%, rgba(124, 77, 255, 0.9) 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .card {
            background: rgba(18, 18, 18, 0.95);
            border: 2px solid #00b0ff;
            border-radius: 15px;
            padding: 40px;
            width: 80%;
            max-width: 600px;
            box-shadow: 0 0 20px rgba(0, 176, 255, 0.3);
            text-align: center;
            animation: cardGlow 2s infinite alternate;
        }

        @keyframes cardGlow {
            from { box-shadow: 0 0 20px rgba(0, 176, 255, 0.3); }
            to { box-shadow: 0 0 30px rgba(0, 176, 255, 0.5); }
        }

        .title {
            color: #fff;
            font-size: 48px;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 10px rgba(0, 176, 255, 0.5);
        }

        .subtitle {
            color: #00b0ff;
            font-size: 24px;
            margin: 10px 0 20px;
        }

        .description {
            color: #bbb;
            font-size: 18px;
            margin: 20px 0;
        }

        .rating {
            color: #ffd700;
            font-size: 30px;
            margin: 20px 0;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .start-btn {
            background: #00b0ff;
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 30px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            transition: all 0.3s ease;
            margin-top: 20px;
            box-shadow: 0 0 15px rgba(0, 176, 255, 0.4);
        }

        .start-btn:hover {
            background: #0091ea;
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0, 176, 255, 0.6);
        }

        #hud {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #00b0ff;
            text-shadow: 0 0 5px rgba(0, 176, 255, 0.5);
            font-size: 16px;
            text-align: right;
            background: rgba(18, 18, 18, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 176, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 176, 255, 0.2);
        }

        #home-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(18, 18, 18, 0.9);
            color: #00b0ff;
            border: 2px solid #00b0ff;
            border-radius: 10px;
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 0 15px rgba(0, 176, 255, 0.2);
        }

        #home-button:hover {
            background: #00b0ff;
            color: #111;
            box-shadow: 0 0 25px rgba(0, 176, 255, 0.4);
            transform: scale(1.05);
        }

        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #fff;
            font-size: 14px;
            pointer-events: none;
            text-align: right;
            background: rgba(18, 18, 18, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 176, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 176, 255, 0.2);
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(18, 18, 18, 0.95);
            color: #fff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #00b0ff;
            box-shadow: 0 0 30px rgba(0, 176, 255, 0.4);
        }

        .game-over h2 {
            color: #00b0ff;
            font-size: 36px;
            margin: 0 0 20px;
            text-transform: uppercase;
        }

        .game-over p {
            color: #fff;
            font-size: 20px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <button id="home-button" onclick="window.location.href='index.html'">Home</button>
    <div id="gameOverlay">
        <div class="card">
            <h1 class="title">Addict 0</h1>
            <h2 class="subtitle">Retro Flight Combat</h2>
            <p class="description">Take to the skies in this retro-inspired flight combat game! Shoot down balloons, earn points, and become the ultimate pilot!</p>
            <div class="rating">★★★</div>
            <button class="start-btn" onclick="this.parentElement.parentElement.style.display='none'">Start Playing</button>
        </div>
    </div>
    <div id="hud">
        <div>Time Remaining: <span id="timer">60</span>s</div>
        <div>Current Score: <span id="score">0</span></div>
        <div>High Score: <span id="highscore">0</span></div>
        <div>Balloons Hit: <span id="balloons-hit">0</span></div>
        <div>Health: <span id="health">100%</span></div>
        <div>Altitude: <span id="altitude">0</span> ft</div>
        <div>Speed: <span id="speed">0</span> kts</div>
    </div>
    <div id="controls">
        Controls:
        <br>- Arrow Keys: Fly the plane
        <br>- W/S: Speed up/down
        <br>- Space: Shoot lasers
        <br>- Hit balloons to score!
    </div>
    <script type="module">
        import * as THREE from 'three';

        class Game {
            constructor() {
                // Check if user is logged in
                const currentUser = localStorage.getItem('current_user');
                if (!currentUser) {
                    alert('Please log in to play!');
                    window.location.href = 'index.html';
                    return;
                }

                // Initialize game
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    logarithmicDepthBuffer: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0xb3e0ff);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                this.clouds = [];
                this.setupLights();
                this.createTerrain();
                this.createPlane();
                this.createBalloons();
                this.setupControls();

                this.animate();

                window.addEventListener('resize', () => this.onWindowResize());
            }

            setupLights() {
                // Increase ambient light intensity by 30%
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.52); // Increased from 0.4 to 0.52
                this.scene.add(ambientLight);

                // Increase sun light intensity by 30%
                this.sunLight = new THREE.DirectionalLight(0xffd500, 1.95); // Increased from 1.5 to 1.95
                this.sunLight.position.set(100, 100, 50);
                this.sunLight.castShadow = true;
                this.sunLight.shadow.mapSize.width = 2048;
                this.sunLight.shadow.mapSize.height = 2048;
                this.scene.add(this.sunLight);

                // Increase hemisphere light intensity by 30%
                const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x639263, 0.78); // Increased from 0.6 to 0.78
                this.scene.add(hemiLight);

                // Add a secondary fill light for better overall illumination
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
                fillLight.position.set(-50, 50, -50);
                this.scene.add(fillLight);
            }

            createTerrain() {
                // Increase renderer clear color brightness by 30%
                this.renderer.setClearColor(0xb3e0ff); // Brighter sky blue color (increased from 0x87CEEB)
                
                // Create ground
                const groundSize = 1400;
                const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 100, 100);
                
                // Create optimized grass texture
                const canvasSize = 128;
                const canvas = document.createElement('canvas');
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                const context = canvas.getContext('2d');
                
                // Draw improved ground texture with variation
                const drawGrass = () => {
                    const baseColor = '#567D46';
                    const variationColors = ['#4A6B3C', '#628952', '#4E7340'];
                    
                    for (let x = 0; x < canvasSize; x += 4) {
                        for (let y = 0; y < canvasSize; y += 4) {
                            context.fillStyle = Math.random() < 0.8 ? baseColor : 
                                variationColors[Math.floor(Math.random() * variationColors.length)];
                            context.fillRect(x, y, 4, 4);
                        }
                    }
                };
                
                drawGrass();
                
                const groundTexture = new THREE.CanvasTexture(canvas);
                groundTexture.wrapS = THREE.RepeatWrapping;
                groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(70, 70);
                
                const groundMaterial = new THREE.MeshLambertMaterial({
                    map: groundTexture,
                    flatShading: true
                });
                
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // Create runway
                const runwayLength = 400;
                const runwayWidth = 40;
                const runwayGeometry = new THREE.PlaneGeometry(runwayWidth, runwayLength);
                
                // Create runway texture
                const runwayCanvas = document.createElement('canvas');
                runwayCanvas.width = 256;
                runwayCanvas.height = 1024;
                const runwayContext = runwayCanvas.getContext('2d');
                
                // Draw runway texture
                runwayContext.fillStyle = '#333333';
                runwayContext.fillRect(0, 0, 256, 1024);
                
                // Add center line stripes
                runwayContext.fillStyle = '#FFFFFF';
                for (let y = 0; y < 1024; y += 100) {
                    runwayContext.fillRect(118, y, 20, 60);
                }
                
                // Add edge lines
                runwayContext.fillRect(0, 0, 10, 1024);
                runwayContext.fillRect(246, 0, 10, 1024);
                
                const runwayTexture = new THREE.CanvasTexture(runwayCanvas);
                runwayTexture.wrapS = THREE.RepeatWrapping;
                runwayTexture.wrapT = THREE.RepeatWrapping;
                
                const runwayMaterial = new THREE.MeshLambertMaterial({
                    map: runwayTexture,
                    flatShading: true
                });
                
                const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
                runway.rotation.x = -Math.PI / 2;
                runway.rotation.z = Math.PI / 2;
                runway.position.y = 0.1; // Slightly above ground to prevent z-fighting
                runway.receiveShadow = true;
                this.scene.add(runway);

                // Create optimized mountains
                this.createVoxelMountains();
                
                // Add trees throughout the terrain
                const treeBoundary = groundSize * 0.45;
                const numberOfTrees = 200;
                
                // Create tree clusters throughout the terrain, avoiding runway area
                for (let i = 0; i < numberOfTrees; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * treeBoundary;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    // Check if tree position is too close to runway
                    const runwayBuffer = 30;
                    if (Math.abs(x) < (runwayWidth/2 + runwayBuffer)) {
                        continue; // Skip this tree if it's too close to runway
                    }
                    
                    // Create clusters of 1-3 trees
                    const clusterSize = Math.floor(Math.random() * 3) + 1;
                    for (let j = 0; j < clusterSize; j++) {
                        const offsetX = (Math.random() - 0.5) * 30;
                        const offsetZ = (Math.random() - 0.5) * 30;
                        this.createTree(
                            x + offsetX,
                            0,
                            z + offsetZ
                        );
                    }
                }
                
                // Create clouds
                this.createPixelClouds();
            }
            
            createVoxelMountains() {
                const createVoxelBlock = (x, y, z, width, height, depth, colorHex) => {
                    const geometry = new THREE.BoxGeometry(width, height, depth);
                    const material = new THREE.MeshLambertMaterial({ 
                        color: colorHex,
                        flatShading: true
                    });
                    const block = new THREE.Mesh(geometry, material);
                    block.position.set(x, y, z);
                    block.castShadow = true;
                    block.receiveShadow = true;
                    return block;
                };

                // Enhanced mountain colors with more variation
                const colors = {
                    snow: [0xFFFFFF, 0xF0F0F0, 0xE8E8E8],
                    rock: [0x6B7280, 0x5A6170, 0x7C8290],
                    darkRock: [0x4B5563, 0x404B57, 0x566270],
                    grass: [0x3B824A, 0x357A44, 0x419755],
                    dirt: [0x8B6D5C, 0x7A5D4E, 0x9C7E6D]
                };
                
                // Create smaller boundary mountains
                const boundaryDistance = 1040;
                const createMountainRange = (startX, startZ, length, direction) => {
                    const peaks = [];
                    const segmentLength = 160;
                    const segments = Math.floor(length / segmentLength);
                    
                    // Generate mountain peaks with reduced height
                    for (let i = 0; i < segments; i++) {
                        const baseHeight = 40 + Math.random() * 30; // Significantly reduced height
                        const peakNoise = Math.sin(i * 0.5) * 20 + Math.random() * 15; // Reduced variation
                        peaks.push(baseHeight + peakNoise);
                    }
                    
                    // Enhanced peak smoothing
                    for (let i = 1; i < peaks.length - 1; i++) {
                        peaks[i] = (peaks[i-1] * 0.25 + peaks[i] * 0.5 + peaks[i+1] * 0.25);
                    }
                    
                    // Create mountain geometry with more detail
                    for (let i = 0; i < segments; i++) {
                        const peakHeight = peaks[i];
                        const pos = direction === 'x' ? 
                            { x: startX + i * segmentLength, z: startZ } :
                            { x: startX, z: startZ + i * segmentLength };
                        
                        // Create layers with more variation
                        for (let y = 0; y < peakHeight; y += 10) {
                            const width = 80 - (y / peakHeight) * 40; // Reduced width
                            const depth = 80 - (y / peakHeight) * 40; // Reduced depth
                            
                            // Select color with variation
                            let colorArray;
                            if (y > peakHeight * 0.85) {
                                colorArray = colors.rock;
                            } else if (y > peakHeight * 0.6) {
                                colorArray = colors.darkRock;
                            } else if (y > peakHeight * 0.3) {
                                colorArray = colors.dirt;
                            } else {
                                colorArray = colors.grass;
                            }
                            
                            const color = colorArray[Math.floor(Math.random() * colorArray.length)];
                            
                            // Add random offset for more natural look
                            const offsetX = (Math.random() - 0.5) * 5;
                            const offsetZ = (Math.random() - 0.5) * 5;
                            
                            const block = createVoxelBlock(
                                pos.x + offsetX,
                                y,
                                pos.z + offsetZ,
                                width * (0.9 + Math.random() * 0.2),
                                10,
                                depth * (0.9 + Math.random() * 0.2),
                                color
                            );
                            
                            this.scene.add(block);
                        }
                    }
                };
                
                // Create mountain ranges on all four boundaries
                createMountainRange(-boundaryDistance, -boundaryDistance, boundaryDistance * 2, 'x');
                createMountainRange(-boundaryDistance, boundaryDistance, boundaryDistance * 2, 'x');
                createMountainRange(-boundaryDistance, -boundaryDistance, boundaryDistance * 2, 'z');
                createMountainRange(boundaryDistance, -boundaryDistance, boundaryDistance * 2, 'z');
            }

            createTree(x, y, z) {
                const treeGroup = new THREE.Group();
                
                // Tree colors
                const colors = {
                    trunk: 0x4A3728,
                    darkLeaves: 0x1F4A25,
                    midLeaves: 0x2D682F,
                    lightLeaves: 0x3B824A
                };
                
                // Create trunk
                const trunkHeight = 20 + Math.random() * 20;
                for (let i = 0; i < trunkHeight; i += 5) {
                    const width = 4 - (i / trunkHeight) * 1.5;
                    const trunk = new THREE.Mesh(
                        new THREE.BoxGeometry(width, 5, width),
                        new THREE.MeshLambertMaterial({ color: colors.trunk })
                    );
                    trunk.position.set(0, y + i, 0);
                    trunk.castShadow = true;
                    trunk.receiveShadow = true;
                    treeGroup.add(trunk);
                }
                
                // Create foliage layers
                const createFoliageLayer = (height, size, color) => {
                    const layer = new THREE.Mesh(
                        new THREE.BoxGeometry(size, size * 0.7, size),
                        new THREE.MeshLambertMaterial({ color: color })
                    );
                    layer.position.set(
                        (Math.random() - 0.5) * 2,
                        height,
                        (Math.random() - 0.5) * 2
                    );
                    layer.rotation.y = Math.random() * Math.PI * 0.25;
                    layer.castShadow = true;
                    layer.receiveShadow = true;
                    treeGroup.add(layer);
                };
                
                // Add foliage layers
                const baseHeight = trunkHeight * 0.6;
                const layerCount = Math.floor(Math.random() * 3) + 3;
                for (let i = 0; i < layerCount; i++) {
                    const height = baseHeight + i * 8;
                    const size = 20 - i * 4;
                    const color = i === 0 ? colors.darkLeaves :
                                i === layerCount - 1 ? colors.lightLeaves :
                                colors.midLeaves;
                    createFoliageLayer(height, size, color);
                }
                
                treeGroup.position.set(x, y, z);
                this.scene.add(treeGroup);
            }

            createPixelClouds() {
                this.clouds = [];
                
                const createPixelCloud = (isAdvertising = false) => {
                    const cloud = new THREE.Group();
                    const blockSize = 20;
                    const vendor = isAdvertising ? this.getRandomVendor() : null;
                    
                    // Cloud pattern - larger for ad clouds
                    const cloudPattern = isAdvertising ? [
                        [0,1,1,1,1,0],
                        [1,1,1,1,1,1],
                        [1,1,1,1,1,1],
                        [0,1,1,1,1,0]
                    ] : [
                        [0,1,1,0],
                        [1,1,1,1],
                        [0,1,1,0]
                    ];
                    
                    const cloudMaterial = new THREE.MeshLambertMaterial({
                        color: isAdvertising ? vendor.color : 0xFFFFFF,
                        transparent: true,
                        opacity: 0.9,
                        flatShading: true
                    });
                    
                    // Create cloud blocks
                    for (let y = 0; y < cloudPattern.length; y++) {
                        for (let x = 0; x < cloudPattern[y].length; x++) {
                            if (cloudPattern[y][x] === 1) {
                                const voxel = new THREE.Mesh(
                                    new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                                    cloudMaterial
                                );
                                voxel.position.set(
                                    (x - cloudPattern[y].length/2) * blockSize,
                                    (y - cloudPattern.length/2) * blockSize * 0.5,
                                    0
                                );
                                cloud.add(voxel);
                            }
                        }
                    }
                    
                    // Add vendor text if it's an advertising cloud
                    if (isAdvertising) {
                        const textGeometry = new THREE.PlaneGeometry(blockSize * 4, blockSize);
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = 256;
                        canvas.height = 64;
                        context.fillStyle = vendor.textColor;
                        context.font = 'bold 32px Orbitron';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(vendor.name, canvas.width/2, canvas.height/2);
                        
                        const textTexture = new THREE.CanvasTexture(canvas);
                        const textMaterial = new THREE.MeshBasicMaterial({
                            map: textTexture,
                            transparent: true,
                            side: THREE.DoubleSide
                        });
                        
                        // Add text on both sides of the cloud
                        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                        textMesh.position.set(0, 0, blockSize * 2);
                        cloud.add(textMesh);
                        
                        const textMeshBack = textMesh.clone();
                        textMeshBack.position.z = -blockSize * 2;
                        textMeshBack.rotation.y = Math.PI;
                        cloud.add(textMeshBack);
                    }
                    
                    return cloud;
                };
                
                // Create a mix of regular and advertising clouds
                for (let i = 0; i < 30; i++) {
                    const isAdvertising = i < 10; // First 10 clouds are ads
                    const cloud = createPixelCloud(isAdvertising);
                    cloud.position.set(
                        (Math.random() - 0.5) * 800,
                        300 + Math.random() * 400, // Higher altitude for better visibility
                        (Math.random() - 0.5) * 800
                    );
                    this.clouds.push(cloud);
                    this.scene.add(cloud);
                }
            }

            createPlane() {
                // Create a Minecraft-style fighter jet
                const planeGroup = new THREE.Group();
                
                // Helper function to create a block
                const createBlock = (width, height, depth, color, x, y, z) => {
                    const geometry = new THREE.BoxGeometry(width, height, depth);
                    const material = new THREE.MeshLambertMaterial({ 
                        color: color,
                        flatShading: true
                    });
                    const block = new THREE.Mesh(geometry, material);
                    block.position.set(x, y, z);
                    block.castShadow = true;
                    planeGroup.add(block);
                    return block;
                };
                
                // Main fuselage (sleeker and longer)
                createBlock(4, 2, 16, 0x3B96D2, 0, 0, 0); // Blue fuselage
                
                // Fighter jet style wings (flat and angled)
                // Left wing
                createBlock(12, 0.5, 8, 0x3B96D2, -6, 0, 2); // Main wing section
                createBlock(4, 0.5, 3, 0x3B96D2, -10, 0, 2); // Wing tip
                
                // Right wing
                createBlock(12, 0.5, 8, 0x3B96D2, 6, 0, 2); // Main wing section
                createBlock(4, 0.5, 3, 0x3B96D2, 10, 0, 2); // Wing tip
                
                // Nose (more pointed)
                createBlock(3, 2, 4, 0xE0E0E0, 0, 0, 9);
                createBlock(2, 1.5, 2, 0xE0E0E0, 0, 0, 11);
                
                // Small tail fin (reduced size)
                createBlock(2, 3, 1, 0x3B96D2, 0, 1.5, -7); // Vertical stabilizer
                
                // Horizontal stabilizers (smaller and angled)
                createBlock(5, 0.5, 3, 0x3B96D2, -2.5, 0, -7); // Left stabilizer
                createBlock(5, 0.5, 3, 0x3B96D2, 2.5, 0, -7); // Right stabilizer
                
                // Cockpit (black blocks)
                createBlock(2, 1, 3, 0x111111, 0, 1, 6);
                
                // Engine exhausts
                createBlock(1, 1, 2, 0x333333, -1, 0, -8);
                createBlock(1, 1, 2, 0x333333, 1, 0, -8);
                
                // Set up the plane
                this.plane = planeGroup;
                
                // Set initial Y rotation to 90 degrees (π/2 radians)
                this.plane.rotation.y = Math.PI / 2;
                
                this.plane.position.set(0, 10, 0);
                this.scene.add(this.plane);

                // Adjust camera parameters for better third-person view
                this.camera.position.set(0, 8, -25);
                this.cameraOffset = new THREE.Vector3(0, 8, -25);
            }

            createBalloons() {
                this.balloons = [];
                const balloonCount = 27; // Increased from 7 to 27
                for (let i = 0; i < balloonCount; i++) {
                    const balloon = this.createBalloon();
                    // Spread balloons over area with better distribution
                    const angle = (i / balloonCount) * Math.PI * 2; // Distribute in a circular pattern
                    const radius = Math.random() * 280 + 140; // Random radius between 140 and 420 units
                    balloon.position.set(
                        Math.cos(angle) * radius, // X position
                        100 + Math.random() * 300, // Y position (height)
                        Math.sin(angle) * radius  // Z position
                    );
                    this.scene.add(balloon);
                    this.balloons.push(balloon);
                }
            }

            createBalloon() {
                // Create Minecraft-style balloon (cube) - 20% larger
                const balloon = new THREE.Group();
                
                // Get random vendor
                const vendor = this.getRandomVendor();

                // Balloon part (cube) - increased size by 20%
                const balloonGeometry = new THREE.BoxGeometry(12, 12, 12); // Increased from 10 to 12
                const balloonMaterial = new THREE.MeshLambertMaterial({
                    color: vendor.color,
                    flatShading: true
                });
                const balloonCube = new THREE.Mesh(balloonGeometry, balloonMaterial);
                balloon.add(balloonCube);

                // Add vendor text to balloon - increased size proportionally
                const textGeometry = new THREE.PlaneGeometry(14.4, 3.6); // Increased from 12,3 to 14.4,3.6
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = vendor.textColor;
                context.font = 'bold 32px Orbitron';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(vendor.name, canvas.width/2, canvas.height/2);
                
                const textTexture = new THREE.CanvasTexture(canvas);
                const textMaterial = new THREE.MeshBasicMaterial({
                    map: textTexture,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.set(0, 0, 6.1); // Adjusted for new size
                balloon.add(textMesh);

                // Mirror text on other side
                const textMeshBack = textMesh.clone();
                textMeshBack.position.z = -6.1; // Adjusted for new size
                textMeshBack.rotation.y = Math.PI;
                balloon.add(textMeshBack);

                // Basket (small cube) - increased proportionally
                const basketGeometry = new THREE.BoxGeometry(4.8, 4.8, 4.8); // Increased from 4 to 4.8
                const basketMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513,
                    flatShading: true 
                });
                const basket = new THREE.Mesh(basketGeometry, basketMaterial);
                basket.position.y = -12; // Adjusted for new size
                balloon.add(basket);

                // Ropes (thin blocks) - adjusted for new size
                const ropeGeometry = new THREE.BoxGeometry(0.6, 7.2, 0.6); // Increased proportionally
                const ropeMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513,
                    flatShading: true 
                });
                
                // Add four ropes at corners - adjusted positions
                for (let x = -1; x <= 1; x += 2) {
                    for (let z = -1; z <= 1; z += 2) {
                        const rope = new THREE.Mesh(ropeGeometry, ropeMaterial);
                        rope.position.set(x * 2.4, -8.4, z * 2.4); // Adjusted for new size
                        balloon.add(rope);
                    }
                }

                // Add collision box for better hit detection
                const hitboxGeometry = new THREE.BoxGeometry(14, 14, 14); // Slightly larger than balloon for better hit detection
                const hitboxMaterial = new THREE.MeshBasicMaterial({
                    visible: false // Invisible hitbox
                });
                const hitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
                hitbox.name = 'hitbox';
                balloon.add(hitbox);

                balloon.vendor = vendor; // Store vendor info
                return balloon;
            }

            // Add vendor management
            getRandomVendor() {
                const vendors = [
                    { name: 'TechCorp', color: 0xFF4081, textColor: '#FFFFFF' },
                    { name: 'GameFuel', color: 0x00BCD4, textColor: '#FFFFFF' },
                    { name: 'PixelPlay', color: 0x4CAF50, textColor: '#FFFFFF' },
                    { name: 'ByteBurst', color: 0xFFC107, textColor: '#000000' },
                    { name: 'CodeCola', color: 0x9C27B0, textColor: '#FFFFFF' }
                ];
                return vendors[Math.floor(Math.random() * vendors.length)];
            }

            setupControls() {
                this.keys = {};
                this.speed = 2;
                this.rollSpeed = 0.05;
                this.pitchSpeed = 0.03;
                this.rudderSpeed = 0.02;
                this.maxSpeed = 5;
                this.minSpeed = 0.5;
                this.speedIncrement = 0.05;
                this.isSuperTurbo = false;
                this.bullets = [];
                this.score = 0;
                this.balloonsHit = 0;
                this.highScore = localStorage.getItem('highScore') || 0;
                this.health = 100;
                this.lastShot = 0;
                this.shootDelay = 250;
                this.gameTime = 60; // 60 seconds game time
                this.isGameActive = true;
                this.velocity = new THREE.Vector3(0, 0, 0); // Initialize velocity vector

                // Update high score display
                document.getElementById('highscore').textContent = this.highScore;

                // Start the game timer
                this.startGameTimer();

                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'Space' && this.isGameActive) {
                        this.shoot();
                    }
                    if (e.code === 'ShiftRight') {
                        this.isSuperTurbo = true;
                        this.maxSpeed = 10;
                    }
                    if (e.code === 'KeyR' && !this.isGameActive) {
                        this.restartGame();
                    }
                    if (e.code === 'KeyV') {
                        // Toggle camera view (you can implement different views)
                    }
                    if (e.code === 'KeyM') {
                        // Mute sound (you can implement sound control)
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                    if (e.code === 'ShiftRight') {
                        this.isSuperTurbo = false;
                        this.maxSpeed = 5; // Reset max speed
                    }
                });
            }

            shoot() {
                const now = performance.now();
                if (now - this.lastShot < this.shootDelay) return;
                
                this.lastShot = now;

                // Create bullet with 300% increased size (doubled again)
                const bulletGeometry = new THREE.BoxGeometry(1.2, 1.2, 12); // Minecraft-style block laser, 300% larger
                const bulletMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 1
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // Add point light to bullet for glow effect
                const bulletLight = new THREE.PointLight(0xff0000, 3, 30); // Stronger light
                bullet.add(bulletLight);
                
                // Position and orient bullet
                bullet.position.copy(this.plane.position);
                bullet.quaternion.copy(this.plane.quaternion);
                
                // Move bullet forward from plane position
                const bulletDirection = new THREE.Vector3(0, 0, 1);
                bulletDirection.applyQuaternion(this.plane.quaternion);
                bullet.position.add(bulletDirection.multiplyScalar(12));
                
                // Store bullet data
                this.bullets.push({
                    mesh: bullet,
                    direction: bulletDirection.clone().normalize(),
                    speed: 10,
                    created: now
                });
                
                this.scene.add(bullet);
                
                // Add Minecraft-style muzzle flash (blocky cube)
                const flashGeometry = new THREE.BoxGeometry(2.5, 2.5, 2.5);
                const flashMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.8
                });
                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                flash.position.copy(bullet.position);
                this.scene.add(flash);
                
                // Remove flash after short delay
                setTimeout(() => {
                    this.scene.remove(flash);
                }, 50);
            }

            startGameTimer() {
                const timerElement = document.getElementById('timer');
                this.gameTimer = setInterval(() => {
                    this.gameTime--;
                    timerElement.textContent = this.gameTime;
                    
                    if (this.gameTime <= 0) {
                        this.endGame();
                    }
                }, 1000);
            }

            endGame() {
                this.isGameActive = false;
                clearInterval(this.gameTimer);
                
                // Update user's scores in localStorage
                const users = JSON.parse(localStorage.getItem('arcade_users')) || {};
                const currentUser = localStorage.getItem('current_user');
                
                if (currentUser && users[currentUser]) {
                    const user = users[currentUser];
                    user.flightHighScore = Math.max(user.flightHighScore || 0, this.score);
                    user.balloonsHit = (user.balloonsHit || 0) + this.balloonsHit;
                    localStorage.setItem('arcade_users', JSON.stringify(users));
                }

                // Remove existing game over message if present
                const existingGameOver = document.getElementById('gameOver');
                if (existingGameOver) {
                    existingGameOver.remove();
                }

                // Create game over message
                const gameOver = document.createElement('div');
                gameOver.className = 'game-over';
                gameOver.id = 'gameOver';
                
                let reason = "Time's up!";
                if (this.health <= 0) {
                    reason = "Crashed!";
                }

                const userHighScore = users[currentUser]?.flightHighScore || this.score;
                
                gameOver.innerHTML = `
                    <h2>Game Over!</h2>
                    <p>${reason}</p>
                    <p>Final Score: ${this.score}</p>
                    <p>Balloons Hit: ${this.balloonsHit}</p>
                    <p>High Score: ${userHighScore}</p>
                    <p>Press R to Restart</p>
                `;
                document.body.appendChild(gameOver);
            }

            restartGame() {
                // Remove game over message if it exists
                const gameOver = document.getElementById('gameOver');
                if (gameOver) {
                    gameOver.remove();
                }

                // Reset game variables
                this.score = 0;
                this.balloonsHit = 0;
                this.health = 100;
                this.gameTime = 60;
                this.isGameActive = true;
                this.speed = 2; // Reset speed to initial value
                
                // Reset plane position and orientation
                this.plane.position.set(0, 10, 0); // Reset to starting position
                this.plane.rotation.set(0, 0, 0); // Reset all rotation
                this.plane.quaternion.set(0, 0, 0, 1); // Reset quaternion
                
                // Reset camera position
                this.camera.position.copy(this.cameraOffset);
                this.camera.lookAt(this.plane.position);
                
                // Update displays
                document.getElementById('score').textContent = '0';
                document.getElementById('balloons-hit').textContent = '0';
                document.getElementById('timer').textContent = '60';
                document.getElementById('speed').textContent = '40'; // 2 * 20 = 40 (initial speed)
                document.getElementById('altitude').textContent = '10';
                document.getElementById('health').textContent = '100%';
                
                // Reset balloon positions
                this.balloons.forEach(balloon => this.scene.remove(balloon));
                this.balloons = [];
                this.createBalloons();

                // Clear any remaining bullets
                this.bullets.forEach(bullet => this.scene.remove(bullet.mesh));
                this.bullets = [];

                // Restart timer
                clearInterval(this.gameTimer);
                this.startGameTimer();
            }

            updateBullets() {
                if (!this.isGameActive) return;
                
                const bulletSpeed = 15;
                
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    
                    // Move bullet in its forward direction
                    const movement = bullet.direction.clone().multiplyScalar(bulletSpeed);
                    bullet.mesh.position.add(movement);
                    
                    // Check distance from player (remove if too far)
                    const distanceFromPlayer = bullet.mesh.position.distanceTo(this.plane.position);
                    if (distanceFromPlayer > 1000 || performance.now() - bullet.created > 2000) {
                        this.scene.remove(bullet.mesh);
                        this.bullets.splice(i, 1);
                        continue;
                    }
                    
                    // Check collision with balloons using raycaster
                    const raycaster = new THREE.Raycaster();
                    raycaster.ray.origin.copy(bullet.mesh.position);
                    raycaster.ray.direction.copy(bullet.direction);
                    
                    // Check each balloon for collision
                    for (let j = this.balloons.length - 1; j >= 0; j--) {
                        const balloon = this.balloons[j];
                        const hitbox = balloon.children.find(child => child.name === 'hitbox');
                        
                        if (hitbox) {
                            const balloonBox = new THREE.Box3().setFromObject(hitbox);
                            const bulletBox = new THREE.Box3().setFromObject(bullet.mesh);
                            
                            if (balloonBox.intersectsBox(bulletBox)) {
                                // Remove bullet
                                this.scene.remove(bullet.mesh);
                                this.bullets.splice(i, 1);
                                
                                // Create explosion effect
                                this.createExplosion(balloon.position.clone());
                                
                                // Remove balloon
                                this.scene.remove(balloon);
                                this.balloons.splice(j, 1);
                                
                                // Update score
                                this.score += 1;
                                this.balloonsHit++;
                                document.getElementById('score').textContent = this.score;
                                
                                // Create new balloon after delay
                                setTimeout(() => {
                                    if (this.isGameActive) {
                                        const newBalloon = this.createBalloon();
                                        newBalloon.position.set(
                                            (Math.random() - 0.5) * 2000,
                                            100 + Math.random() * 300,
                                            (Math.random() - 0.5) * 2000
                                        );
                                        this.scene.add(newBalloon);
                                        this.balloons.push(newBalloon);
                                    }
                                }, 3000);
                                
                                break;
                            }
                        }
                    }
                }
            }

            createExplosion(position) {
                // Create explosion light
                const explosionLight = new THREE.PointLight(0xff6600, 3, 30);
                explosionLight.position.copy(position);
                this.scene.add(explosionLight);
                
                // Create explosion particles
                const particleCount = 40;
                const explosionGroup = new THREE.Group();
                
                for (let i = 0; i < particleCount; i++) {
                    const size = Math.random() * 0.8 + 0.2;
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(size, 8, 8),
                        new THREE.MeshBasicMaterial({
                            color: i % 3 === 0 ? 0xff0000 : i % 3 === 1 ? 0xff6600 : 0xffff00,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    
                    // Random position within explosion radius
                    const radius = Math.random() * 2;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    particle.position.set(
                        position.x + radius * Math.sin(phi) * Math.cos(theta),
                        position.y + radius * Math.sin(phi) * Math.sin(theta),
                        position.z + radius * Math.cos(phi)
                    );
                    
                    // Random velocity
                    const speed = 2 + Math.random() * 3;
                    particle.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * speed,
                        (Math.random() - 0.3) * speed,
                        (Math.random() - 0.5) * speed
                    );
                    
                    // Store initial size for scaling during animation
                    particle.initialScale = particle.scale.clone();
                    
                    explosionGroup.add(particle);
                }
                
                this.scene.add(explosionGroup);
                
                // Animate explosion
                const startTime = performance.now();
                const duration = 1000; // 1 second explosion
                
                const animateExplosion = () => {
                    const elapsed = performance.now() - startTime;
                    const progress = elapsed / duration;
                    
                    if (progress >= 1) {
                        this.scene.remove(explosionGroup);
                        this.scene.remove(explosionLight);
                        return;
                    }
                    
                    // Update particles
                    explosionGroup.children.forEach(particle => {
                        // Move according to velocity
                        particle.position.add(particle.velocity);
                        
                        // Add gravity effect
                        particle.velocity.y -= 0.05;
                        
                        // Scale down over time
                        const scale = 1 - progress;
                        particle.scale.copy(particle.initialScale).multiplyScalar(scale);
                        
                        // Fade out
                        particle.material.opacity = 0.8 * (1 - progress);
                    });
                    
                    // Fade out light
                    explosionLight.intensity = 3 * (1 - progress);
                    
                    requestAnimationFrame(animateExplosion);
                };
                
                animateExplosion();
            }

            applyScreenShake(intensity = 0.02, duration = 150) {
                const originalPosition = this.camera.position.clone();
                let startTime = performance.now();

                const shake = () => {
                    let elapsed = performance.now() - startTime;
                    if (elapsed < duration) {
                        const shakeAmount = intensity * (1 - elapsed / duration);
                        this.camera.position.x = originalPosition.x + (Math.random() - 0.5) * shakeAmount;
                        this.camera.position.y = originalPosition.y + (Math.random() - 0.5) * shakeAmount;
                        this.camera.position.z = originalPosition.z + (Math.random() - 0.5) * shakeAmount;
                        requestAnimationFrame(shake);
                    } else {
                        this.camera.position.copy(originalPosition); // Reset position
                    }
                };
                shake();
            }

            getTerrainHeight(x, z) {
                // Simple flat terrain with a base height of 0
                return 0;
            }

            updatePlane() {
                if (!this.isGameActive) return;

                // Throttle control (W/S)
                if (this.keys['KeyW']) {
                    this.speed = Math.min(this.speed + this.speedIncrement, this.maxSpeed);
                } else if (this.keys['KeyS']) {
                    this.speed = Math.max(this.speed - this.speedIncrement, this.minSpeed);
                }

                // Create directional vectors
                const forward = new THREE.Vector3(0, 0, 1);
                const up = new THREE.Vector3(0, 1, 0);
                const right = new THREE.Vector3(1, 0, 0);

                // Reset rotation if it becomes unstable
                if (isNaN(this.plane.rotation.x) || isNaN(this.plane.rotation.y) || isNaN(this.plane.rotation.z)) {
                    this.plane.rotation.set(0, this.plane.rotation.y, 0);
                }

                // Set proper Euler order
                this.plane.rotation.order = 'YXZ';

                // Bank and turn (Left/Right arrows)
                if (this.keys['ArrowLeft']) {
                    // Roll left with limit
                    const targetRoll = -0.5; // Reduced maximum bank angle
                    this.plane.rotation.z = THREE.MathUtils.lerp(
                        this.plane.rotation.z,
                        targetRoll,
                        0.05  // Reduced turn sensitivity
                    );
                    
                    // Turn rate based on bank angle
                    this.plane.rotation.y += 0.03;
                } else if (this.keys['ArrowRight']) {
                    // Roll right with limit
                    const targetRoll = 0.5; // Reduced maximum bank angle
                    this.plane.rotation.z = THREE.MathUtils.lerp(
                        this.plane.rotation.z,
                        targetRoll,
                        0.05  // Reduced turn sensitivity
                    );
                    
                    // Turn rate based on bank angle
                    this.plane.rotation.y -= 0.03;
                } else {
                    // Auto-level roll more smoothly
                    this.plane.rotation.z = THREE.MathUtils.lerp(
                        this.plane.rotation.z,
                        0,
                        0.1
                    );
                }

                // Pitch control (Up/Down arrows)
                if (this.keys['ArrowUp']) {
                    const targetPitch = -0.4; // Reduced pitch angle
                    this.plane.rotation.x = THREE.MathUtils.lerp(
                        this.plane.rotation.x,
                        targetPitch,
                        0.05
                    );
                } else if (this.keys['ArrowDown']) {
                    const targetPitch = 0.4; // Reduced pitch angle
                    this.plane.rotation.x = THREE.MathUtils.lerp(
                        this.plane.rotation.x,
                        targetPitch,
                        0.05
                    );
                } else {
                    // Auto-level pitch more smoothly
                    this.plane.rotation.x = THREE.MathUtils.lerp(
                        this.plane.rotation.x,
                        0,
                        0.1
                    );
                }

                // Ensure rotation stays within safe limits
                this.plane.rotation.x = THREE.MathUtils.clamp(this.plane.rotation.x, -Math.PI/3, Math.PI/3);
                this.plane.rotation.z = THREE.MathUtils.clamp(this.plane.rotation.z, -Math.PI/3, Math.PI/3);

                // Calculate movement direction
                const direction = forward.clone();
                direction.applyQuaternion(this.plane.quaternion);

                // Add lift and banking effects
                const baseLift = 0.02;
                const speedLift = this.speed * 0.01;
                const pitchLift = -this.plane.rotation.x * 0.3; // Reduced pitch effect
                direction.y += baseLift + speedLift + pitchLift;

                // Reduce lift during steep banks
                if (Math.abs(this.plane.rotation.z) > 0.2) {
                    direction.y -= Math.abs(this.plane.rotation.z) * 0.05;
                }

                // Move plane
                const movement = direction.multiplyScalar(this.speed);
                this.plane.position.add(movement);

                // Apply gravity
                if (this.plane.position.y > 1) {
                    const gravityForce = 0.015 * (1 - Math.min(this.speed / this.maxSpeed, 1) * 0.8);
                    this.plane.position.y -= gravityForce;
                }

                // Prevent going below ground
                if (this.plane.position.y < 1) {
                    this.plane.position.y = 1;
                    if (this.speed > 3) {
                        document.getElementById('health').textContent = '0%';
                    }
                }

                // Update camera position
                const idealOffset = new THREE.Vector3(0, 8, -25);
                idealOffset.applyQuaternion(this.plane.quaternion);
                const targetCameraPos = this.plane.position.clone().add(idealOffset);
                this.camera.position.lerp(targetCameraPos, 0.1);

                // Look ahead of the plane
                const lookAhead = this.plane.position.clone().add(direction.multiplyScalar(10));
                lookAhead.y += 2; // Look slightly above the nose
                this.camera.lookAt(lookAhead);

                // Update HUD
                document.getElementById('altitude').textContent = Math.round(this.plane.position.y);
                document.getElementById('speed').textContent = Math.round(this.speed * 20);

                // --- Ground Collision Check ---
                const groundHeight = this.getTerrainHeight(this.plane.position.x, this.plane.position.z);
                if (this.plane.position.y <= groundHeight + 1) { // Check slightly above ground
                    const impactSpeed = Math.abs(direction.y * this.speed * 1000); // Use vertical speed for impact force
                    let damage = 0;

                    if (impactSpeed > 500) { // Minor bump
                        damage = Math.min(10 + (impactSpeed - 500) / 50, 25); // Scale damage
                        this.applyScreenShake(0.01, 100); // Small shake
                    }
                    if (impactSpeed > 1500) { // Hard impact
                        damage = Math.min(25 + (impactSpeed - 1500) / 30, 75); // Higher damage scaling
                        this.applyScreenShake(0.03, 200); // Medium shake
                    }
                     if (impactSpeed > 3000) { // Crash
                        damage = 100; // Instant game over
                        this.applyScreenShake(0.05, 300); // Large shake
                    }
                    
                    if (damage > 0) {
                        this.health -= damage;
                        this.health = Math.max(0, this.health); // Clamp health at 0
                        document.getElementById('health').textContent = `${Math.round(this.health)}%`;

                        // Bounce the plane slightly
                        this.plane.position.y = groundHeight + 1.1;
                        // Reduce downward movement on impact
                        if (direction.y < 0) {
                            this.plane.position.y += Math.min(-direction.y * 0.01, 2);
                        }
                    }

                    if (this.health <= 0) {
                        this.endGame();
                        return; // Stop further updates this frame
                    }
                }
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                this.updatePlane();
                this.updateBullets();

                // Optimize cloud animation with reduced boundaries
                const time = performance.now() * 0.001;
                this.clouds.forEach((cloud, index) => {
                    cloud.position.x += 0.2;
                    if (cloud.position.x > 400) { // Decreased from 800
                        cloud.position.x = -400; // Decreased from -800
                    }
                    // Make advertising clouds rotate slowly to face player
                    if (cloud.children.length > 4) {
                        cloud.lookAt(this.camera.position);
                    }
                });

                // Optimize balloon animation
                this.balloons.forEach((balloon, index) => {
                    balloon.position.y += Math.sin(time + index) * 0.05;
                    balloon.rotation.y = (time + index) * 0.2;
                });

                this.renderer.render(this.scene, this.camera);
            }

            // Update the initialization of high score
            initializeScores() {
                this.score = 0;
                this.balloonsHit = 0;
                
                const users = JSON.parse(localStorage.getItem('arcade_users')) || {};
                const currentUser = localStorage.getItem('current_user');
                
                if (currentUser && users[currentUser]) {
                    this.highScore = users[currentUser].flightHighScore || 0;
                } else {
                    this.highScore = 0;
                }
                
                document.getElementById('score').textContent = this.score;
                document.getElementById('highscore').textContent = this.highScore;
                document.getElementById('balloons-hit').textContent = this.balloonsHit;
            }
        }

        // Start the game
        window.onload = () => {
            new Game();
        };
    </script>
</body>
</html> 